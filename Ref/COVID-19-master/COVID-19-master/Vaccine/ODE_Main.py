import pulp
import random
import networkx as nx
import simpy
import numpy as np
import pickle
import random
import math
import operator
import itertools
import pandas as pd
import decimal

from geopy import distance
from scipy import optimize
from sklearn.cluster import KMeans
from scipy.spatial.distance import *
from scipy import stats
import matplotlib.pyplot as plt
from geopy.distance import geodesic
from scipy.optimize import minimize, differential_evolution
from sklearn.metrics import silhouette_score, calinski_harabasz_score


def compare(Vaccines_Received, score):

    global z
    bins = {i: [] for i in range(10)}

    for i in range(z):
        bins[int(np.mean(score[i]) * 10)].append(i)

    V = [(0, 0) for i in range(10)]
    for k in bins.keys():
        x = np.mean([np.mean(score[v]) for v in bins[k]])
        y = np.mean([np.mean(Vaccines_Received[v]) for v in bins[k]])

        V[k] = (x, y)
    return V


def vaccinate(A, z_total, Vaccines_Received):

    global z, rE, rP, learning_rate, how_many_vac, vaccine_distribution, Im
    for i in range(z):
        how_many_for_me = np.sum(A[:, i])
        Vaccines_Received[i].append(how_many_for_me)

        for h in range(how_many_vac):
            num = 0.0
            for j in range(int(how_many_for_me * vaccine_distribution[h])):
                if random.uniform(0, 1) < rE[h][i]:
                    z_total[i][0] -= 1
                    z_total[i][3] += 1
                    Im[i][t][h] += 1
                    num += 1.0

            rP[h][i] = rP[h][i] + (num/(how_many_for_me * vaccine_distribution[h] + 1.0) - rP[h][i]) * learning_rate
    return z_total, Vaccines_Received


def least_distance_per_cluster(C, arr):
    array = np.zeros((len(arr), len(arr)))
    for row in range(len(arr)):
        for column in range(len(arr)):
            array[row][column] = euclidean(C[arr[row]], C[arr[column]])
    avg_distance = (np.mean(array, axis=1)).reshape(len(arr), )
    least = np.amin(avg_distance)
    result = 0
    for et in range(len(avg_distance)):
        if avg_distance[et] == least:
            result = arr[et]
            break
    return result


def mean_plot(Trace, z):

    multiple_lists = [Trace[i] for i in range(z)]
    arrays = [np.array(x) for x in multiple_lists]
    return [np.mean(k) for k in zip(*arrays)]


def opt(zid, z_total, repeat):

    global beta, sigma, gamma, alphas, P
    z0 = z_total[zid]

    z0[0] = z0[0] + (-beta[zid] * z0[0] * z0[2]) / P[zid]
    z0[1] = z0[1] + (beta[zid] * z0[0] * z0[2]) / P[zid] - (sigma[repeat] * z0[1])
    z0[2] = z0[2] + sigma[repeat] * z0[1] - gamma * z0[2]
    z0[3] = z0[3] + gamma * (1.0 - alphas) * z0[2]
    z0[4] = z0[4] + sigma[repeat] * alphas * z0[2]

    z_total[zid] = z0
    return z_total


def beta_values():

    global file, mid_B

    B = np.array(file['Population Density'].values)
    beta_arr = [((B[i] - np.mean(B)) / np.sum(B) + 1.0) * mid_B for i in range(z)]
    return beta_arr


def optimize(z_total, score):

    global warehouse, initialT, z, trade_off, P, rP, how_many_vac, vaccine_distribution

    S = [z_total[i][0] for i in range(z)]
    E = [z_total[i][1] for i in range(z)]
    I = [z_total[i][2] for i in range(z)]
    R = [z_total[i][3] for i in range(z)]
    D = [z_total[i][4] for i in range(z)]

    # T = int(min(initialT, np.max(S)))
    T = initialT
    # print ("T:", T, np.sum(S))

    # Equally distributing vaccines across warehouse zones
    VW = {}
    current_warehouse = 0
    for f in range(1, initialT + 1):
        VW[f - 1] = LW[current_warehouse]
        if f % (T / warehouse) == 0:
            current_warehouse += 1

    # print (np.mean(S), np.mean(P), np.mean(I), np.mean(rP))

    model = pulp.LpProblem("Vaccine problem", pulp.LpMinimize)
    X = pulp.LpVariable.dicts("X", ((i, j) for i in range(warehouse) for j in range(z)), lowBound = 0.0,
                              upBound=int(T / warehouse), cat='Continuous')

    dist_array = [geodesic(C[VW[j]], C[b]).miles for j in range(T) for b in range(z)]
    max_dist = np.max(dist_array)
    den_economic = float(T * max_dist)
    model += np.sum(
        [X[j, b] * geodesic(C[LW[j]], C[b]).miles for j in range(warehouse) for b in range(z)]) / den_economic

    ir = [I[i] / (P[i] + 0.000001) for i in range(z)]
    Z_I = [((ir[i] - np.mean(ir)) / np.sum(ir)) + 1.0 for i in range(z)]
    Z_B = [((beta[i] - np.mean(beta)) / np.sum(beta)) + 1.0 for i in range(z)]

    # Constraint 1 --------------------------------------------------------------------------

    for i in range(warehouse):
        # Condition 1: If you must assign all the vaccines generated by a warehouse
        model += pulp.lpSum([X[(i, j)] for j in range(z)]) == int(T/warehouse)

        # Condition 2: If you want to minimize the number of vaccines
        # model += pulp.lpSum([X[(i, j)] for j in range(z)]) <= int(T / warehouse)

    # Constraint 2 --------------------------------------------------------------------------

    s = 0.0
    for i in range(warehouse):
        s += pulp.lpSum([X[(i, j)] for j in range(z)])

    # Condition 1: If you must assign all the vaccines generated by a warehouse
    model += s == T

    # Condition 2: If you want to minimize the number of vaccines
    # model += s <= T

    # Constraint 3 (fairness lower) ---------------------------------------------------------
    another_arr = []
    for i in range(z):
        # Condition 3: If calculation is based on susceptible population
        rPeff = sum([vaccine_distribution[h] * rP[h][i] for h in range(how_many_vac)])
        # print (rPeff)

        c = (S[i] - rPeff * pulp.lpSum([X[(j, i)] for j in range(warehouse)])) / sum(S)
        # c = 1/z

        # Condition 4: To include population density
        c *= Z_B[i]

        # Condition 5: To include infected population
        c *= Z_I[i]

        model += pulp.lpSum([X[(j, i)] for j in range(warehouse)]) >= trade_off * c * T

    for i in range(z):
        score[i].append(S[i]/max(S) * ir[i]/max(ir) * beta[i]/max(beta))
    # Condition 3 only
    # another_arr = [(S[i])/(max(S)) for i in range(z)]

    # Condition 3 + 4
    # another_arr = [(S[i]*beta[i])/(max(S)*max(beta)) for i in range(z)]

    # Condition 3 + 4 + 5
    # another_arr = [(S[i]*ir[i]*beta[i])/(np.max(S)*np.max(ir)*np.max(beta)) for i in range(z)]

    # -----------------------------------------------------------------------------------------

    model.solve()
    print(pulp.LpStatus[model.status])

    # Transferred the pulp decision to the numpy array (A)
    A = np.zeros((T, z))
    for i in range(warehouse):
        for j in range(z):
            A[i, j] = X[(i, j)].varValue

    # print ('Number of vaccines:', np.sum(A))
    return A, score


def recurrence(z_total, t, frac):
    global Im, delay, z, rec

    tot = 0
    # print('Zone ', t, tot, sum([z_total[l][0] for l in range(z)]),
    # max([z_total[l][3] for l in range(z)]))

    # For each zone
    for i in range(z):

        recurs = random.uniform(0, frac) * z_total[i][3]
        if t >= delay:
            val = Im[i][t - delay]

            # For each vaccine type
            for j in range(len(val)):
                recurs += int(rec[j] * val[j])
                Im[i][t - delay][j] -= recurs
                z_total[i][3] -= recurs
                z_total[i][0] += recurs

        tot += recurs

    print('Zone ', t, tot)

    return z_total, tot


z = 45
mid_B = 3.0
initialT = 2000
trade_off = 0.95
learning_rate = 0.2

# File used for importing data
file = pd.read_csv("covid_confirmed_NY_july.csv")

# Population count for each zone
P = file.iloc[0:z, 2]
I = file.iloc[0:z, 3]

C = []
coordinates = np.array(file['Location'].values)
for a in range(0, len(coordinates)):
    arr = coordinates[a].split(', ')
    for b in range(0, len(arr)):
        arr[b] = float(arr[b])
    C.append((arr[1], arr[0]))

file = file.iloc[0:z, :]

# Parameters for transitioning between states
beta = beta_values()

# Exposed fraction
pe = 0.3

Duration = 250
warehouse = 5

kmeans = KMeans(n_clusters = warehouse, random_state = 0).fit(C)
cluster_center = kmeans.cluster_centers_
cluster_labels = kmeans.labels_

label_arr = [[] for alpha in range(warehouse)]
for i in range(len(cluster_labels)):
    label_arr[cluster_labels[i]].append(i)

# List of warehouses
LW = [least_distance_per_cluster(C, label_arr[i]) for i in range(warehouse)]

sigma = [0.001, 0.2]  # np.mean([1/3, 1/5])
gamma = 0.1  # np.mean([1/5, 1/18])
alphas = 0.05
clist = ['blue', 'green']
# labels = [r'$\sigma$ = ' + str(0.05), r'$\sigma$ = ' + str(0.20)]
labels = ['Susceptible', 'Infected']

how_many_vac = 2
vaccine_distribution = [0.5, 0.5]
# vaccine_distribution = [1.0]

# Immunity ratio
rP = {h: [0.4 for i in range(z)] for h in range(how_many_vac)}
# rE = {h: [0.2 for i in range(z)] for h in range(how_many_vac)}
rE = {0: [0.9 for i in range(z)], 1: [0.6 for i in range(z)]}
# E = {0: [0.9 for i in range(z)]}

# Recurrence of disease given vaccine
rec = [0.5, 0.5]
# rec = [0.7]

z_total = {i: [P[i] - pe * P[i] - I[i], pe * P[i], I[i], 0, 0] for i in range(z)}
print (z_total)
# exit(1)

Vaccines_Received = {i: [] for i in range(z)}
score = {i: [] for i in range(z)}

# Log of (zone X time) immunization count in ordered pair (vac1, vac2, ...)
Im = [[[0 for _ in range(how_many_vac)] for j in range(Duration)] for i in range(z)]
delay = 135

# Fraction of people vaccinated people who may transfer anyway
frac = 0.001

change_immunity_ratio = []
for repeat in range(1):
    Trace = {i: [] for i in range(z)}

    changeRate = False
    for t in range(Duration):
        print ('Time:', t)

        for zone in range(z):
            z_total = opt(zone, z_total, repeat)

        A, score = optimize(z_total, score)
        z_total, Vaccines_Received = vaccinate(A, z_total, Vaccines_Received)
        # z_total, tot = recurrence(z_total, t, frac)

        # for zone in range(z):
        #     Trace[zone].append([z_total[zone][0], np.mean(rP)])

        # if t >= Duration/2 and not changeRate:
        #     changeRate = True
        #     for h in range(how_many_vac):
        #         l = rE[h]
        #         rE[h] = [0.6 for i in range(len(l))]

        # print (t, rP[0][0], rP[1][0])
        print (t, np.mean(rP[0]), np.std(rP[0]))
        print (t, np.mean(rP[1]), np.std(rP[1]))

        # print ('***')
        #
        change_immunity_ratio.append((np.mean(rP[0]), np.std(rP[0]), np.mean(rP[1]), np.std(rP[1])))
        # change_immunity_ratio.append((rP[0][0], 0, rP[1][0], 0))

        # change_immunity_ratio.append((np.mean(rP[0]), np.std(rP[0])))
        # print (sum([z_total[i][0] for i in range(z)]), sum([z_total[i][3] for i in range(z)]), tot)
        # change_immunity_ratio.append((sum([z_total[i][0] for i in range(z)]), tot))
    # print (Vaccines_Received)
    # print (score)
    # V = compare(Vaccines_Received, score)
    # print (V)

    # for zone in range(z):
    #     ax1.plot([t for t in range(Duration)], [v[0] for v in Trace[zone]], color = clist[0], linewidth = 1, alpha = 0.2)
    #     # plt.plot([t for t in range(Duration)], Vaccines_Received[zone], color = clist[0], linewidth = 1, alpha = 0.2)
    #
    # ax2.plot([t for t in range(Duration)], [v[1] for v in Trace[0]], color = clist[1], linewidth = 2, alpha = 1)
    # ax2.plot([t for t in range(Duration)], [0.2 for v in Trace[0]], color = 'black', linewidth = 2, alpha = 1, linestyle = 'dotted')
    # plt.plot([t for t in range(Duration)], mean_plot([Vaccines_Received[zone] for zone in range(z)], z), color = clist[1], linewidth = 2, label = 'Mean allocation', linestyle = 'dashdot')

# ax1.set_xlabel('Duration in days', fontsize = 15)
# ax1.set_ylabel('Number of susceptible individuals', fontsize = 15, color = clist[0])
# ax2.set_ylabel('Predicted immunity ratio', fontsize = 15, color = clist[1])
# plt.xlabel('Duration in days', fontsize = 15)
# plt.xlabel('Number of vaccines received', fontsize = 15)
print (change_immunity_ratio)
# plt.hist([np.mean(Vaccines_Received[i]) for i in range(z)], bins = 10, density = False)
# plt.hist([np.mean(score[i]) for i in range(z)], bins = [0.1 * i for i in range(10)], density = False, edgecolor = 'black')
# plt.xlabel('Score bracket', fontsize = 15)
# plt.ylabel('Frequency', fontsize = 15)
#
# # plt.legend(fontsize = 15)
# plt.tight_layout()
# plt.savefig('scale.png')
# plt.show()

pickle.dump(change_immunity_ratio, open('change4.p', 'wb'))
plt.plot([i for i in range(len(change_immunity_ratio))], [val[0] for val in change_immunity_ratio])
plt.plot([i for i in range(len(change_immunity_ratio))], [val[2] for val in change_immunity_ratio])

# plt.axhline(y = 0.4, color='r', linestyle='-')
# plt.axhline(y = 0.1, color='g', linestyle='-')
# plt.axhline(y = 0.3, color='g', linestyle='-')
plt.show()
# print (change_immunity_ratio)
# pickle.dump(change_immunity_ratio, open('change4-80-150.p', 'wb'))
